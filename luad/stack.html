<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>luad.stack</title>
        </head><body>
        <h1>luad.stack</h1>
        <!-- Generated by Ddoc from luad\stack.d -->
This module takes care of converting between D and Lua types.
<br><br>
The conversion rules are as follows, where conversion goes both ways:
<dl><dt>boolean
		<dd>bool</dd>
	</dt>
	<dt>number
		<dd>implicitly convertible to lua_Integer (default int) or lua_Number (default double)</dd>
	</dt>
	<dt>string
		<dd>string or implicitly convertible to const(char)*</dd>
	</dt>
	<dt>table
		<dd>associative arrays, arrays, structs, LuaTable</dd>
	</dt>
	<dt>function
		<dd>function pointers, delegates, LuaFunction</dd>
	</dt>
	<dt>userdata
		<dd>classes</dd>
	</dt>
	<dt>any of the above
		<dd>LuaObject</dd>
	</dt>
</dl>
The conversions are checked in the specified order. For example, even though bool is implicitly convertible
to lua_Integer, it will be converted to a boolean because boolean has precedence.<br><br>

<dl><dt><big>void <u>pushValue</u>(T)(lua_State* <i>L</i>, T <i>value</i>);
</big></dt>
<dd>Push a value of any type to the stack.
<br><br>
<b>Params:</b><br>
<table><tr><td>L</td>
<td>stack to push to</td></tr>
<tr><td>value</td>
<td>value to push</td></tr>
</table><br>

</dd>
<dt><big>int <u>luaTypeOf</u>(T)();
</big></dt>
<dd>Get the associated Lua type for T.
<br><br>
<b>Returns:</b><br>
Lua type for T<br><br>

</dd>
<dt><big>T <u>getValue</u>(T, alias typeMismatchHandler = defaultTypeMismatch)(lua_State* <i>L</i>, int <i>idx</i>);
</big></dt>
<dd>Get a value of any type from the stack.
<br><br>
<b>Params:</b><br>
<table><tr><td>T</td>
<td>type of value</td></tr>
<tr><td>typeMismatchHandler</td>
<td>function called to produce an error in case of an invalid conversion.</td></tr>
<tr><td>L</td>
<td>stack to get from</td></tr>
<tr><td>idx</td>
<td>value stack index</td></tr>
</table><br>

</dd>
<dt><big>LuaObject[] <u>getStack</u>(lua_State* <i>L</i>);
</big></dt>
<dd>Get all objects on a stack, then clear the stack.
<br><br>
<b>Params:</b><br>
<table><tr><td>lua_State* <i>L</i></td>
<td>stack to dump</td></tr>
</table><br>
<b>Returns:</b><br>
array of objects<br><br>

</dd>
<dt><big>T <u>popValue</u>(T, alias typeMismatchHandler = defaultTypeMismatch)(lua_State* <i>L</i>);
</big></dt>
<dd>Same as calling getValue!(T, typeMismatchHandler)(L, -1), then popping one value from the stack.
<br><br>
<b>See Also:</b><br>
getValue<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>. </small>
        </body></html>
